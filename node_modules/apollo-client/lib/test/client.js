"use strict";
var chai = require('chai');
var assert = chai.assert;
var src_1 = require('../src');
var graphql_1 = require('graphql');
var redux_todomvc_1 = require('./fixtures/redux-todomvc');
var redux_1 = require('redux');
var networkInterface_1 = require('../src/networkInterface');
var chaiAsPromised = require('chai-as-promised');
chai.use(chaiAsPromised);
describe('client', function () {
    it('does not require any arguments and creates store lazily', function () {
        var client = new src_1.default();
        assert.isUndefined(client.store);
        client.initStore();
        assert.isDefined(client.store);
        assert.isDefined(client.store.getState().apollo);
    });
    it('can allow passing in a network interface', function () {
        var networkInterface = networkInterface_1.createNetworkInterface('swapi');
        var client = new src_1.default({
            networkInterface: networkInterface,
        });
        assert.equal(client.networkInterface._uri, networkInterface._uri);
    });
    it('can allow passing in a store', function () {
        var client = new src_1.default();
        var store = redux_1.createStore(redux_1.combineReducers({
            todos: redux_todomvc_1.rootReducer,
            apollo: client.reducer(),
        }), redux_1.applyMiddleware(client.middleware()));
        assert.deepEqual(client.store.getState(), store.getState());
    });
    it('throws an error if you pass in a store without apolloReducer', function () {
        try {
            var client = new src_1.default();
            redux_1.createStore(redux_1.combineReducers({
                todos: redux_todomvc_1.rootReducer,
            }), redux_1.applyMiddleware(client.middleware()));
            assert.fail();
        }
        catch (error) {
            assert.equal(error.message, 'Existing store does not use apolloReducer for apollo');
        }
    });
    it('has a top level key by default', function () {
        var client = new src_1.default();
        client.initStore();
        assert.deepEqual(client.store.getState(), {
            apollo: {
                queries: {},
                mutations: {},
                data: {},
            },
        });
    });
    it('can allow passing in a top level key', function () {
        var reduxRootKey = 'test';
        var client = new src_1.default({
            reduxRootKey: reduxRootKey,
        });
        client.initStore();
        assert.deepEqual(client.store.getState(), (_a = {},
            _a[reduxRootKey] = {
                queries: {},
                mutations: {},
                data: {},
            },
            _a
        ));
        var _a;
    });
    it('should allow for a single query to take place', function (done) {
        var query = "\n      query people {\n        allPeople(first: 1) {\n          people {\n            name\n          }\n        }\n      }\n    ";
        var data = {
            allPeople: {
                people: [
                    {
                        name: 'Luke Skywalker',
                    },
                ],
            },
        };
        var networkInterface = mockNetworkInterface({
            request: { query: query },
            result: { data: data },
        });
        var client = new src_1.default({
            networkInterface: networkInterface,
        });
        return client.query({ query: query })
            .then(function (result) {
            assert.deepEqual(result, { data: data });
            done();
        });
    });
    it('should allow for a single query with existing store', function (done) {
        var query = "\n      query people {\n        allPeople(first: 1) {\n          people {\n            name\n          }\n        }\n      }\n    ";
        var data = {
            allPeople: {
                people: [
                    {
                        name: 'Luke Skywalker',
                    },
                ],
            },
        };
        var networkInterface = mockNetworkInterface({
            request: { query: query },
            result: { data: data },
        });
        var client = new src_1.default({
            networkInterface: networkInterface,
        });
        redux_1.createStore(redux_1.combineReducers({
            todos: redux_todomvc_1.rootReducer,
            apollo: client.reducer(),
        }), redux_1.applyMiddleware(client.middleware()));
        return client.query({ query: query })
            .then(function (result) {
            assert.deepEqual(result, { data: data });
            done();
        });
    });
    it('can allow a custom top level key', function (done) {
        var query = "\n      query people {\n        allPeople(first: 1) {\n          people {\n            name\n          }\n        }\n      }\n    ";
        var data = {
            allPeople: {
                people: [
                    {
                        name: 'Luke Skywalker',
                    },
                ],
            },
        };
        var networkInterface = mockNetworkInterface({
            request: { query: query },
            result: { data: data },
        });
        var reduxRootKey = 'test';
        var client = new src_1.default({
            networkInterface: networkInterface,
            reduxRootKey: reduxRootKey,
        });
        return client.query({ query: query })
            .then(function (result) {
            assert.deepEqual(result, { data: data });
            done();
        });
    });
    it('allows for a single query with existing store and custom key', function (done) {
        var reduxRootKey = 'test';
        var query = "\n      query people {\n        allPeople(first: 1) {\n          people {\n            name\n          }\n        }\n      }\n    ";
        var data = {
            allPeople: {
                people: [
                    {
                        name: 'Luke Skywalker',
                    },
                ],
            },
        };
        var networkInterface = mockNetworkInterface({
            request: { query: query },
            result: { data: data },
        });
        var client = new src_1.default({
            reduxRootKey: reduxRootKey,
            networkInterface: networkInterface,
        });
        redux_1.createStore(redux_1.combineReducers((_a = {
                todos: redux_todomvc_1.rootReducer
            },
            _a[reduxRootKey] = client.reducer(),
            _a
        )), redux_1.applyMiddleware(client.middleware()));
        return client.query({ query: query })
            .then(function (result) {
            assert.deepEqual(result, { data: data });
            done();
        });
        var _a;
    });
    it('should return errors correctly for a single query', function (done) {
        var query = "\n      query people {\n        allPeople(first: 1) {\n          people {\n            name\n          }\n        }\n      }\n    ";
        var errors = [
            {
                name: 'test',
                message: 'Syntax Error GraphQL request (8:9) Expected Name, found EOF',
            },
        ];
        var networkInterface = mockNetworkInterface({
            request: { query: query },
            result: { errors: errors },
        });
        var client = new src_1.default({
            networkInterface: networkInterface,
        });
        return client.query({ query: query })
            .then(function (result) {
            assert.deepEqual(result, { errors: errors });
            done();
        });
    });
    it('should allow for subscribing to a request', function (done) {
        var query = "\n      query people {\n        allPeople(first: 1) {\n          people {\n            name\n          }\n        }\n      }\n    ";
        var data = {
            allPeople: {
                people: [
                    {
                        name: 'Luke Skywalker',
                    },
                ],
            },
        };
        var networkInterface = mockNetworkInterface({
            request: { query: query },
            result: { data: data },
        });
        var client = new src_1.default({
            networkInterface: networkInterface,
        });
        var handle = client.watchQuery({ query: query });
        handle.onResult(function (result) {
            assert.deepEqual(result.data, data);
            done();
        });
    });
});
function mockNetworkInterface(mockedRequest) {
    var requestToResultMap = {};
    var request = mockedRequest.request, result = mockedRequest.result;
    requestToResultMap[requestToKey(request)] = result;
    var queryMock = function (req) {
        return new Promise(function (resolve, reject) {
            var resultData = requestToResultMap[requestToKey(req)];
            if (!resultData) {
                throw new Error("Passed request that wasn't mocked: " + requestToKey(req));
            }
            resolve(resultData);
        });
    };
    return {
        query: queryMock,
    };
}
function requestToKey(request) {
    var query = request.query && graphql_1.print(graphql_1.parse(request.query));
    return JSON.stringify({
        variables: request.variables,
        query: query,
    });
}
//# sourceMappingURL=client.js.map